name: CI

on:
  push:
    branches:
      - master
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  lint-format:
    runs-on:
      - x64
    steps:
      - name: Checkout repository (full clone)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Bandit checks
        run: nix develop -L .#ci-bandit --command bandit -ll -r selfprivacy_api

      - name: Run code formatting checks
        run: nix develop -L .#ci-black --command black --check .

  tests-and-sonar:
    runs-on:
      - kvm
    needs:
      - lint-format
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run tests and coverage
        run: |
          nix build -L .#checks.x86_64-linux.default
          cp result/coverage.xml/coverage.xml coverage.xml

      - name: Upload results to SonarQube
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
        run: |
          # Base SonarQube parameters
          SONAR_PARAMS="-Dsonar.projectKey=SelfPrivacy-REST-API"
          SONAR_PARAMS="$SONAR_PARAMS -Dsonar.sources=."
          SONAR_PARAMS="$SONAR_PARAMS -Dsonar.host.url=https://analyzer.selfprivacy.org"
          SONAR_PARAMS="$SONAR_PARAMS -Dsonar.token=$SONAR_TOKEN"
          SONAR_PARAMS="$SONAR_PARAMS -Dsonar.python.coverage.reportPaths=coverage.xml"
          SONAR_PARAMS="$SONAR_PARAMS -Dsonar.python.version=3.12"

          # Check if this is a pull request
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            echo "Detected PR #${{ github.event.pull_request.number }}"
            SONAR_PARAMS="$SONAR_PARAMS -Dsonar.pullrequest.key=${{ github.event.pull_request.number }}"
            SONAR_PARAMS="$SONAR_PARAMS -Dsonar.pullrequest.branch=${{ github.head_ref }}"
            SONAR_PARAMS="$SONAR_PARAMS -Dsonar.pullrequest.base=${{ github.base_ref }}"
          elif [ "${{ github.ref_name }}" != "master" ] && [ "${{ github.ref_name }}" != "main" ]; then
            echo "Detected branch: ${{ github.ref_name }}"
            SONAR_PARAMS="$SONAR_PARAMS -Dsonar.branch.name=${{ github.ref_name }}"
          else
            echo "Analyzing main branch"
          fi

          # Run SonarQube scanner
          nix develop -L .#ci-sonar --command sonar-scanner $SONAR_PARAMS

  sonar-quality-gate:
    runs-on:
      - x64
    needs:
      - tests-and-sonar
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Wait for SonarQube analysis
        run: sleep 10

      - name: Check Quality Gate and report issues
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          SONAR_URL="https://analyzer.selfprivacy.org"
          PROJECT_KEY="SelfPrivacy-REST-API"
          PR_KEY="${PR_NUMBER}"

          echo "Checking quality gate for PR #${PR_NUMBER}..."


          QG_DETAILS=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_URL/api/qualitygates/project_status?projectKey=$PROJECT_KEY&pullRequest=$PR_KEY")
          QG_STATUS=$(echo "$QG_DETAILS" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "[DEBUG] Quality Gate Status: $QG_STATUS" >&2

          echo "[DEBUG] Fetching issues for PR..." >&2
          ISSUES=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_URL/api/issues/search?components=$PROJECT_KEY&pullRequest=$PR_KEY&resolved=false&ps=100")
          BLOCKER_COUNT=$(echo "$ISSUES" | jq '[.issues[] | select(.severity == "BLOCKER")] | length')
          CRITICAL_COUNT=$(echo "$ISSUES" | jq '[.issues[] | select(.severity == "CRITICAL")] | length')
          MAJOR_COUNT=$(echo "$ISSUES" | jq '[.issues[] | select(.severity == "MAJOR")] | length')
          MINOR_COUNT=$(echo "$ISSUES" | jq '[.issues[] | select(.severity == "MINOR")] | length')
          echo "[DEBUG] Issue counts: Blocker=$BLOCKER_COUNT, Critical=$CRITICAL_COUNT, Major=$MAJOR_COUNT, Minor=$MINOR_COUNT" >&2

          echo "[DEBUG] Fetching measures for PR..." >&2
          MEASURES=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_URL/api/measures/component?component=$PROJECT_KEY&pullRequest=$PR_KEY&metricKeys=new_coverage,new_duplicated_lines_density,new_lines,new_security_hotspots,new_vulnerabilities,new_bugs,new_code_smells")
          get_measure() {
            echo "$MEASURES" | jq -r --arg key "$1" '.component.measures[]? | select(.metric == $key) | .period.value // empty'
          }
          NEW_COVERAGE=$(get_measure "new_coverage")
          NEW_DUPLICATIONS=$(get_measure "new_duplicated_lines_density")
          NEW_LINES=$(get_measure "new_lines")
          NEW_VULNERABILITIES=$(get_measure "new_vulnerabilities")
          NEW_BUGS=$(get_measure "new_bugs")
          NEW_CODE_SMELLS=$(get_measure "new_code_smells")
          NEW_HOTSPOTS=$(get_measure "new_security_hotspots")
          echo "[DEBUG] Extracted measures: Coverage=$NEW_COVERAGE, Duplications=$NEW_DUPLICATIONS, Lines=$NEW_LINES, Vulnerabilities=$NEW_VULNERABILITIES, Bugs=$NEW_BUGS, CodeSmells=$NEW_CODE_SMELLS, Hotspots=$NEW_HOTSPOTS" >&2

          # Set defaults if empty
          NEW_COVERAGE=${NEW_COVERAGE:-"N/A"}
          NEW_DUPLICATIONS=${NEW_DUPLICATIONS:-"0.0"}
          NEW_LINES=${NEW_LINES:-"0"}
          NEW_VULNERABILITIES=${NEW_VULNERABILITIES:-"0"}
          NEW_BUGS=${NEW_BUGS:-"0"}
          NEW_CODE_SMELLS=${NEW_CODE_SMELLS:-"0"}
          NEW_HOTSPOTS=${NEW_HOTSPOTS:-"0"}

          # Create comment body with a unique identifier
          COMMENT='<!-- sonarqube-analysis-bot -->\n'
          COMMENT="${COMMENT}## SonarQube Analysis Results\n\n"
          COMMENT="${COMMENT}**Quality Gate:** "

          if [ "$QG_STATUS" = "OK" ]; then
            COMMENT="${COMMENT}âœ… Passed\n\n"
          else
            COMMENT="${COMMENT}âŒ Failed\n\n"
          fi

          COMMENT="${COMMENT}### New Code Metrics\n\n"
          COMMENT="${COMMENT}| Metric | Value |\n"
          COMMENT="${COMMENT}|--------|-------|\n"
          COMMENT="${COMMENT}| ðŸ“Š Coverage on New Code | ${NEW_COVERAGE}% |\n"
          COMMENT="${COMMENT}| ðŸ“ New Lines | ${NEW_LINES} |\n"
          COMMENT="${COMMENT}| ðŸ”„ Duplications | ${NEW_DUPLICATIONS}% |\n"
          COMMENT="${COMMENT}| ðŸ› New Bugs | ${NEW_BUGS} |\n"
          COMMENT="${COMMENT}| ðŸ” New Vulnerabilities | ${NEW_VULNERABILITIES} |\n"
          COMMENT="${COMMENT}| ðŸ”¥ New Security Hotspots | ${NEW_HOTSPOTS} |\n"
          COMMENT="${COMMENT}| ðŸ’¡ New Code Smells | ${NEW_CODE_SMELLS} |\n\n"

          COMMENT="${COMMENT}### All Issues by Severity\n\n"
          COMMENT="${COMMENT}- ðŸ”´ Blocker: $BLOCKER_COUNT\n"
          COMMENT="${COMMENT}- ðŸŸ  Critical: $CRITICAL_COUNT\n"
          COMMENT="${COMMENT}- ðŸŸ¡ Major: $MAJOR_COUNT\n"
          COMMENT="${COMMENT}- ðŸ”µ Minor: $MINOR_COUNT\n\n"
          COMMENT="${COMMENT}[View detailed report]($SONAR_URL/dashboard?id=$PROJECT_KEY&pullRequest=$PR_KEY)"


          printf "%s\n" "$COMMENT" > /tmp/sonar-comment.txt

          # Check if a comment from this bot already exists
          echo "[DEBUG] Fetching existing PR comments from Forgejo..." >&2
          EXISTING_COMMENTS=$(curl -s \
            -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
            "${{ github.api_url }}/repos/${{ github.repository }}/issues/$PR_NUMBER/comments")


          # Look for existing comment with our identifier using jq
          COMMENT_ID=$(echo "$EXISTING_COMMENTS" | jq -r '.[] | select(.body | contains("sonarqube-analysis-bot")) | .id' | head -1)
          echo "[DEBUG] Existing SonarQube comment ID: $COMMENT_ID" >&2

          if [ -n "$COMMENT_ID" ]; then
            echo "[DEBUG] Updating existing comment (ID: $COMMENT_ID)..." >&2
            RESPONSE=$(curl -s -w "\n[DEBUG] Forgejo PATCH HTTP status: %{http_code}\n" -X PATCH \
              -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{\"body\":\"$(cat /tmp/sonar-comment.txt)\"}" \
              "${{ github.api_url }}/repos/${{ github.repository }}/issues/comments/$COMMENT_ID")
            echo "$RESPONSE" >&2
          else
            echo "[DEBUG] Creating new comment..." >&2
            RESPONSE=$(curl -s -w "\n[DEBUG] Forgejo POST HTTP status: %{http_code}\n" -X POST \
              -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{\"body\":\"$(cat /tmp/sonar-comment.txt)\"}" \
              "${{ github.api_url }}/repos/${{ github.repository }}/issues/$PR_NUMBER/comments")
            echo "$RESPONSE" >&2
          fi

          # Fail the job if quality gate failed
          if [ "$QG_STATUS" != "OK" ]; then
            echo "Quality gate failed!"
            exit 1
          fi

  dependency-changes:
    runs-on:
      - x64
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: head

      - name: Checkout PR base
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.sha }}
          path: base

      - name: Compare flake.lock and report dependency changes
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set +e  # Don't exit on diff failure

          echo "[DEBUG] Comparing flake.lock files..." >&2
          diff -q base/flake.lock head/flake.lock
          DIFF_EXIT=$?

          if [ $DIFF_EXIT -eq 0 ]; then
            echo "[DEBUG] No changes in flake.lock, skipping dependency comparison" >&2
            exit 0
          fi

          echo "[DEBUG] flake.lock has changed, generating dependency reports..." >&2

          # Build dependency JSON for base
          cd base
          nix build -L .#dependencies-json
          cp result base-deps.json
          cd ..

          # Build dependency JSON for head
          cd head
          nix build -L .#dependencies-json
          cp result head-deps.json
          cd ..

          # Generate comparison report
          cat > /tmp/compare-deps.py << 'PYEOF'
          import json
          import sys

          with open("base/base-deps.json") as f:
              base_data = json.load(f)

          with open("head/head-deps.json") as f:
              head_data = json.load(f)

          # Create dictionaries with full metadata
          base_deps = {dep["name"]: dep for dep in base_data["dependencies"]}
          head_deps = {dep["name"]: dep for dep in head_data["dependencies"]}

          changes = []

          # Check for version changes and removals
          for name, base_dep in base_deps.items():
              if name not in head_deps:
                  changes.append(("removed", name, base_dep, None))
              elif base_dep["version"] != head_deps[name]["version"]:
                  changes.append(("changed", name, base_dep, head_deps[name]))

          # Check for additions
          for name, head_dep in head_deps.items():
              if name not in base_deps:
                  changes.append(("added", name, None, head_dep))

          if not changes:
              print("NO_CHANGES")
              sys.exit(0)

          def get_link_url(dep):
              """Get the best URL for a dependency, prioritizing changelog over homepage."""
              if dep is None:
                  return None
              # Priority: changelog first, then homepage
              return dep.get("changelog") or dep.get("homepage")

          def format_package_name(name, dep):
              """Format package name as a link if URL is available."""
              url = get_link_url(dep)
              if url:
                  return f"[`{name}`]({url})"
              return f"`{name}`"

          # Generate markdown table
          print("<!-- dependency-changes-bot -->")
          print("## ðŸ“¦ Dependency Changes")
          print()
          print("| Package | Base Version | Head Version | Change |")
          print("|---------|--------------|--------------|--------|")

          for change_type, name, base_dep, head_dep in sorted(changes, key=lambda x: (x[0], x[1])):
              if change_type == "added":
                  pkg_name = format_package_name(name, head_dep)
                  head_ver = head_dep["version"]
                  print(f"| {pkg_name} | - | `{head_ver}` | âž• Added |")
              elif change_type == "removed":
                  pkg_name = format_package_name(name, base_dep)
                  base_ver = base_dep["version"]
                  print(f"| {pkg_name} | `{base_ver}` | - | âž– Removed |")
              elif change_type == "changed":
                  # For changed packages, prefer head metadata
                  pkg_name = format_package_name(name, head_dep)
                  base_ver = base_dep["version"]
                  head_ver = head_dep["version"]
                  print(f"| {pkg_name} | `{base_ver}` | `{head_ver}` | ðŸ”„ Updated |")
          PYEOF

          # Run comparison script
          python3 /tmp/compare-deps.py > /tmp/deps-comment.txt
          COMPARISON_EXIT=$?

          if [ $COMPARISON_EXIT -ne 0 ] || grep -q "NO_CHANGES" /tmp/deps-comment.txt; then
            echo "[DEBUG] No dependency version changes detected" >&2
            exit 0
          fi

          echo "[DEBUG] Dependency changes detected, posting comment..." >&2
          cat /tmp/deps-comment.txt >&2

          # Check if a comment from this bot already exists
          EXISTING_COMMENTS=$(curl -s \
            -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
            "${{ github.api_url }}/repos/${{ github.repository }}/issues/$PR_NUMBER/comments")

          COMMENT_ID=$(echo "$EXISTING_COMMENTS" | jq -r '.[] | select(.body | contains("dependency-changes-bot")) | .id' | head -1)
          echo "[DEBUG] Existing dependency comment ID: $COMMENT_ID" >&2

          # Build JSON payload using jq to properly escape content
          COMMENT_JSON=$(jq -n --rawfile body /tmp/deps-comment.txt '{body: $body}')

          if [ -n "$COMMENT_ID" ]; then
            echo "[DEBUG] Updating existing comment (ID: $COMMENT_ID)..." >&2
            curl -s -X PATCH \
              -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "$COMMENT_JSON" \
              "${{ github.api_url }}/repos/${{ github.repository }}/issues/comments/$COMMENT_ID"
          else
            echo "[DEBUG] Creating new comment..." >&2
            curl -s -X POST \
              -H "Authorization: token ${{ secrets.FORGEJO_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "$COMMENT_JSON" \
              "${{ github.api_url }}/repos/${{ github.repository }}/issues/$PR_NUMBER/comments"
          fi

          echo "[DEBUG] Dependency changes comment posted successfully" >&2
